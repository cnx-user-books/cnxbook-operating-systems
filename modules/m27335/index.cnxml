<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Project 1: Exceptions and Simple System Calls</title>
  <metadata>
  <md:content-id>m27335</md:content-id><md:title>Project 1: Exceptions and Simple System Calls</md:title>
  <md:abstract>Operating Systems	
One-month project</md:abstract>
  <md:uuid>342ea9e1-3fbb-41bf-a6ad-4082fefc0c83</md:uuid>
</metadata>

<content>
    <para id="id3335472">The first project is designed to further your understanding of the relationship between the operating system and user programs. In this assignment, you will implement simple system call traps. In Nachos, an exception handler handles all system calls. You are to handle user program run time exceptions as well as system calls for IO processing. We give you some of the code you need; your job is to complete the system and enhance it.</para>
    <section id="id-062400195483">
      <title>Phase 1: Understand the Code</title>
      <para id="id3335504">The first step is to read and understand the part of the system we have written for you. Our code can run a single user-level ‘C’ program at a time. As a test case, we’ve provided you with a trivial user program, ‘halt’; all halt does is to turn around and ask the operating system to shut the machine down. Run the program ‘nachos –rs 1023 -x ../test/halt’. As before, trace what happens as the user program gets loaded, runs, and invokes a system call.</para>
      <para id="id3335539">The files for this assignment are:</para>
      <para id="id3335544"><emphasis>progtest.cc</emphasis> : test routines for running user programs.</para>
      <para id="id3335556"><emphasis>syscall.h</emphasis> : the system call interface: kernel procedures that user programs can invoke.</para>
      <para id="id3335570"><emphasis>exception.cc</emphasis> : the handler for system calls and other user-level exceptions, such as page faults. In the code we supply, only the ‘halt’ system call is supported.</para>
      <para id="id3335589"><emphasis>bitmap.*</emphasis> : routines for manipulating bitmaps (this might be useful for keeping track of physical page frames)</para>
      <para id="id3335603"><emphasis>filesys.h</emphasis> : defines all file operations</para>
      <para id="id3335616"><emphasis>openfile.h</emphasis> : (found in the filesys directory) a stub defining the Nachos file system routines. For this assignment, we have implemented the Nachos file system by making the corresponding calls to the UNIX file system directly.  Because the calls are made directly, it’s necessary to debug only one thing at a time. In assignment four, we'll implement the Nachos file system for real on a simulated disk</para>
      <para id="id3335635"><emphasis>translate.*</emphasis> : translation table routines. In the code we supply, we assume that every virtual address is the same as its physical address -- this restricts us to running one user program at a time. You will generalize this to allow multiple user programs to be run concurrently in a later lab. </para>
      <para id="id3335658"><emphasis>machine.*</emphasis> : emulates the part of the machine that executes user programs like main memory, processor registers, etc.</para>
      <para id="id3335672"><emphasis>mipssim.cc</emphasis> : emulates the integer instruction set of a MIPS R2/3000 processor.</para>
      <para id="id3335686"><emphasis>console.*</emphasis> : emulates a terminal device using UNIX files. A terminal is byte-oriented and allows incoming bytes to be read and written at the same time.  Bytes arrive asynchronously –as a result of user keystrokes—without being explicitly requested.</para>
      <para id="id3335703"><emphasis>synchconsole.*</emphasis> : routine to synchronize lines of I/O in Nachos. Use the synchconsole class to ensure that your lines of text from your programs are not intermixed.</para>
      <para id="id3335720"><emphasis>../test/*</emphasis> : C programs that will be cross-compiled to MIPS and run in Nachos</para>
    </section>
    <section id="id-759115249541">
      <title>Phase 2: Design Considerations</title>
      <para id="id3335742">In order to fully realize how an operating system works, it is important to understand the distinction between kernel (system space) and user space. Each process in a system has its own local information, including program counters, registers, stack pointers, and file system handles. Although the user program has access to many of the local pieces of information, the operating system controls the access. The operating system is responsible for ensuring that any user program request to the kernel does not cause the operating system to crash. The transfer of control from the user level program to the system call occurs through the use of a “system call” or “software interrupt/trap”. Before invoking the transfer from the user to the kernel, any information that needs to be transferred from the user program to the system call must be loaded into the registers of the CPU. For pass by value items, this process merely involves placing the value into the register. For pass by reference items, the value placed into the register is known as a “user space pointer”. Since the user space pointer has no meaning to the kernel, we will have to translate the contents of the user space into the kernel such that we can manipulate the information. When returning information from a system call to the user space, information must be placed in the CPU registers to indicate either the success of the system call or the appropriate return value. </para>
      <para id="id3335799">Nachos gives you a simulated CPU that models a real CPU. In fact, the simulated CPU is the same as the real CPU (a MIPS chip), but we cannot just run user programs as regular UNIX processes, because we want complete control over how many instructions are executed at a time, how the address spaces work, and how interrupts and exceptions (including system calls) are handled.</para>
      <para id="id3335814">Nachos provided simulator can run normal programs compiled from C -- see the Makefile in the ‘test’ subdirectory for an example. The compiled programs must be linked with some special flags, then converted into Nachos format, using the program “coff2noff”</para>
    </section>
    <section id="id-877561285455">
      <title>Phase 3: [80%] Exceptions and IO System Calls + [10%] Correct design and implementation of encrypted file types</title>
      <para id="id3335842">Implement exception handling and handle the basic system calls for file IO. (All system calls are listed in syscall.h) We have provided you an assembly-language routine, ‘syscall’, to provide a way of invoking a system call from a C routine (UNIX has something similar -- try ‘man syscall’). You will need to do the following steps. NOTE : You should -NOT alter the code within the machine directory, only the code within the userprog directory. </para>
      <list id="id3335904" list-type="bulleted">
        <item>Alter exception.cc to handle all of system exceptions as listed in machine/machine.h Most of the exceptions listed in this file are comprised of run time errors, from which the user program will be unable to recover. The only special cases are no exception, which will return control to the operating system and syscall exception, which will handle our user system calls. For all other exceptions, the operating system should print an error message and Halt the simulation.</item>
        <item>Create a control structure that can handle the various Nachos system calls. Test your control structure by re-implementing the void Halt() system call. Make sure that this call operates in the same manner as we discussed during the Nachos walkthrough; it should cause the Nachos simulation to terminate immediately. Test the call’s accuracy with the test user program.</item>
        <item>All system calls beyond Halt() will require that Nachos increment the program counter before the system call returns. If this is not properly done, Nachos will execute the system call forever. Since the MIPS emulator handles look ahead program counters, as well as normal ones, you will have to emulate the program counter increment code as found in the machine directory. You will have to copy the code into your syscall exception handler and insert it at the proper place. For now, you will have to use the Halt() system call at the end of each of your user programs. </item>
        <item>Implement the int CreateFile(char *name) system call. The createfile system call will use the Nachos Filesystem Object Instance to create a zero length file. Remember, the filename exists in user space. This means the buffer that the user space pointer points to must be translated from user memory space to system memory space. The createfile system call returns 0 for successful completion, -1 for an error.</item>
        <item>Implement the OpenFileID Open(char *name, int type) and int Close(OpenFileID id) system calls. The user program can open two types of “files”, files that can be read only and files that can be read and write. Each process will allocate a fixed size file descriptor table. For now, set this size to be 10 file descriptors. The first two file descriptors, 0 and 1, will be reserved for console input and console output respectively. The open file system call will be responsible for translating the user space buffers when necessary and allocating the appropriate kernel constructs. You will use the filesystem objects provided to you in the filesystem directory. (NOTE: We are using the FILESYSTEM_STUB code) The calls will use the Nachos Filesystem Object Instance to open and close files. The Open system call returns the file descriptor id (OpenFileID == an integer number), or –1 if the call fails. Open can fail for several reasons, such as trying to open a file or mailbox that does not exist or if there is not enough room in the file descriptor table. The type parameter will be set to 0 for a standard file and 1 for a read only file, 2 for encrypted files. Encrypted files will have modified read and writes that encrypt the content. If the type parameter is set to any other value, the system call should fail. The close system call will take a file descriptor as the parameter. The system call will return –1 on failure and 0 on success.</item>
        <item>For crypto files any simple encryption /decryption scheme can be used. E.g. a separate character mapping table can be maintained that maps one character to a different character. Write method will use this mapping table for encryption and read method will use the inverse of the mapping table for decryption.</item>
        <item>Implement the int Read(char *buffer, int charcount, OpenFileID id) and int Write(char *buffer, int charcount, OpenFileID id) system calls. These system calls respectively read and write to a file descriptor ID. Remember, you must translate the character buffers appropriately and you must differentiate between console IO (OpenFileID 0 and 1) and File (any other valid OpenFileID). The read and write interaction will work as follows: </item>
      </list>
      <para id="id3336251">For console read and write, you will use the SynchConsole class, instantiated through the gSynchConsole global variable. You will use the default SynchConsole behaviors for read and write, however you will be responsible for returning the correct types of values to the user. Read and write to Console will return the actual number of characters read or written, not the requested number of characters. In the case of read or write failure to console, the return value should be –1. End of file from the console is returned when the user types in Control-A. Read and write for console will use ASCII data for input and output. (Remember, ASCII data is NULL (\0) terminated)</para>
      <para id="id3336289">For file read and write, you will use the supplied classes in file system. You will use the default filesystem behaviors, however, you will return the same type of return values as for synchconsole. Both read and write will return the actual number of characters read and written. Both system calls will return –1 for failure. Read and write for files will use binary data for input and output.</para>
      <list id="id3336319" list-type="bulleted">
        <item>Implement the int Seek(int pos, OpenFileID id) system call. Seek will move the file cursor to a specified location. The parameter pos will be the absolute character position within a file. If pos is a –1, the position will be moved to the end of file. The system call will return the actual file position upon success, -1 if the call fails. Seeks on console IO will fail. </item>
        <item>Implement a createfile user program to test the createfile system call. You are not going to pass command line arguments to the call, so you will have to either use a fixed filename, or prompt the user for one when you have console IO working.</item>
        <item>Implement a help user program. All help does is it prints a list to standard output of all the user programs you are going to create or have created in the test directory. Help should list each program and a brief 1 line description of each program. (NOTE: This is nothing fancy, just calls using the Write() system call to standard output.)</item>
        <item>Implement an echo user program. For each line of input from the console, the line gets echoed back to the console.</item>
        <item>Implement a cat user program. Ask for a filename, and display the contents of the file to the console.</item>
        <item>Implement a copy user program. Ask for a source and destination filename and copy the file.</item>
        <item>Implement a reverse user program. This program asks for a source and destination file, takes input from the source file, reverses the source file and writes it to the destination.</item>
        <item>Implement encrypt that will take a simple character input file and create a new encrypted file.</item>
        <item>Implement decrypt that take an encrypted file and create a new decrypted file.</item>
        <item>Implement any other tests you feel are necessary to ensure the correctness of your solution. BIG HINT: Implement tests to cover some of the things we changed that are not tested by parts h through m.</item>
      </list>
      <para id="id3336603">NOTE: A large portion of your grade will depend not only on the correctness of your implementation but how accurately your code conforms to the system call specifications presented in this document. As we are building a robust operating system, the user should not be able to perform any system call that will crash Nachos. The worse case scenario is that the user program might generate a Nachos runtime exception, which you will be handling within part a.</para>
    </section>
    <section id="id-479950346081">
      <title>Phase 4: [10%] Documentation</title>
      <para id="id3336635">This includes internal documentation (comments) and a BRIEF, BUT COMPLETE external document (read as: paper) describing what you did to the code and why you made your choices. Everybody needs to demo their project (whether completed or not) to Teaching Assistants (TAs) to get a grade for the project. Demonstration times will be posted after the due date. Submit the documentation online on the due date and take a hardcopy with when you demo the project to the TA for grading. DO NOT PARAPHRASE THIS LAB DESCRIPTION AND DO NOT TURN IN A PRINTOUT OF YOUR CODE AS THE EXTERNAL DOCUMENTATION</para>
    </section>
    <section id="id-0922918630537">
      <title>Deliverables and grading</title>
      <para id="id3336677">When you complete your project, remove all executables and object files. If you want me to read a message with your code, create a README.NOW file and place it in the nachos code directory. Tar and compress the code, and submit the file using the online submission system. It is important that you follow the design guidelines presented for the system calls. I will be running my own shells and test programs against your code to determine how accurately you designed your lab, and how robust your answers are. Grading for the implementation portion will depend on how robust and how accurate your solution is. Remember, the user should not be able to do anything to corrupt the system, and system calls should trap as many error conditions as possible.</para>
    </section>
  </content>
</document>